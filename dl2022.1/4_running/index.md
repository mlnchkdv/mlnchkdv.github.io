# [⬅Глубокое обучение 2022.1](../index.html)

## Разработка и запуск нейронных сетей

[TOC]



### Преодобработка данных





### Проектирование нейронных сетей





### Фреймворки глубокого обучения





### Запуск нейронной сети в облаке - на примере распознания рукописных цифр

Для облачного запуска воспользуемся сервисом [*Google Colaboratory*](https://neural-university.ru/vocabulary-neural-netwoks#rec118268861). В облаке установлен интерпретатор *Python*, различные библиотеки машинного обучения, плюс к этому, выделяется вычислительные ресурсы (*GPU Tesla K80*), которые можно использовать для обучения нейронных сетей.

Запускать *Google Colaboratory* рекомендуется под *Google Chrome*, и при первой попытке открыть ноутбук (так называется любой документ в *Google Colaboratory*) вам будет предложено установить в браузер приложение *Colaboratory*, чтобы в будущем оно автоматически "подхватывало" файлы такого типа или его можно установить по [ссылке](https://chrome.google.com/webstore/detail/open-in-colab/iogfkhleblhcpcekbiedikdehleodpjo?hl=ru&utm_source=chrome-ntp-launcher).



#### Интерфейс *Google Colaboratory*

Первым делом необходимо подключиться к вычислительным ресурсам, которые нам предоставляет *Google*. Для этого в верхней правой части окна нажмите на *Connect - connect to hosted runtime*.

![](.\images\01_colab_interface.webp)

Ожидаем подключения и видим примерно такую картину:

![](.\images\02_colab_interface.webp)

Следующим шагом мы идем в верхнее меню и выбираем *Runtime - Change runtime type*:

![](.\images\03_colab_interface.webp)

В открывшемся окне настроек ноутбука выбираем *Python 3*, а в качестве ускорителя указываем *GPU*, т.е. графическую карту и нажимаем *Save*.

![](.\images\04_colab_interface.webp)

И, наконец, последний момент. Если мы работаем с уже готовым ноутбуком и хотим иметь возможность его править, нам нужно сохранить себе его копию, поэтому выбираем в верхнем меню *«File – Save a copy to Drive…»*

![](.\images\05_colab_interface.webp)

В результате этого действия копия этого файла сохранится на ваш *Google Drive* и автоматически откроется в соседней вкладке.



#### Обучающий набор данных

В качестве обучающего набора рукописные цифр, воспользуемся набором данных MNIST. Это специальный набор данных, в котором собрано большое количество изображений рукописных цифр от 0 до 9.

> Ранее она активно использовалась почтой США при распознавании цифр почтовых индексов, а сейчас она очень часто применяется именно в демонстрационных целях, чтобы показать, как работают несложные нейронные сети.



#### Подготовка кода

Первым делом подключаем необходимые библиотеки:

```python
from tensorflow.keras.datasets import mnist
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense
from tensorflow.keras import utils
from tensorflow.keras.preprocessing import image
from google.colab import files
import numpy as np
import matplotlib.pyplot as plt
from scipy.misc import toimage
%matplotlib inline 
```

В первой строке мы импортируем предустановленный датасет MNIST с изображениями рукописных цифр, которые мы будем распознавать.

Затем мы подключаем библиотеки Sequential и Dense т.к. работаем с полносвязной сетью прямого распространения.

Наконец, мы импортируем дополнительные библиотеки, позволяющие нам работать с данными (NumPy, Matplotlib и др.).

Сразу обратите внимание на модульную структуру ноутбука, благодаря которой вы можете в любом порядке чередовать блоки кода и текстовые поля.

Для того, чтобы добавить новую ячейку кода, текстовое поле или поменять порядок их следования воспользуйтесь, кнопками CODE, TEXT и CELL прямо под основным меню.

![](.\images\07_colab_interface.webp)

Для того, чтобы добавить комментарий непосредственно к ячейке, сослаться на нее, добавить форму или удалить её, нажмите на три точки в верхней правой части любой ячейки и увидите соответствующее меню.

![](.\images\08_colab_interface.webp)

Для запуска фрагмента кода нам нужно просто нажать на значок *play* слева вверху от кода. Он появляется при выделении блока с кодом, либо при наведении мышки на пустые квадратные скобки, если блок не выделен.



##### Подготовка данных для обучения сети

Следующим шагом с помощью функции `load_data` мы подгружаем данные, необходимые для обучения сети, где `x_train_org` и `y_train_org` – данные обучающей выборки, а `x_test_org` и `y_test_org` – данные тестовой выборки.

Их названий выборок понятно, что обучающую выборку мы используем для того, чтобы обучить сеть, в то время как тестовая используется для того, чтобы проверить, насколько качественно произошло это обучение.

Смысл тестовой выборки в том, чтобы проверить, насколько точно отработает наша сеть с данными, с которыми она не сталкивалась ранее. Именно это является самой важной метрикой оценки сети.

![](.\images\09_colab_interface.webp)

В `x_train_org` находятся сами изображения цифр, на которых обучается сеть, а `y_train_org` – правильные ответы, какая именно цифра изображена на том или ином изображении.

> Сразу важно отметить, что формат представления правильных ответов на выходе из сети - одномерный массив (вектор), хранящий 10 цифр – 0 или 1. При этом положение единицы в этом векторе и говорит нам о верном ответе.
>
> Например, если цифра на картинке изображен 0, то вектор будет выглядеть как в первой строке на картинке ниже.
>
> Если на изображении цифра 2, то единица в векторе будет стоять в 3 позиции (как в строке 2).
>
> Если же на изображении цифра 9, то единица в векторе будет стоять в последней, десятой позиции.
>
> Это объясняется тем, что нумерация в массивах по умолчанию начинается с нуля.

```python
# 0 -> [1, 0, 0, 0, 0, 0, 0, 0, 0, 0]
# 2 -> [0, 0, 1, 0, 0, 0, 0, 0, 0, 0]
# 9 -> [0, 0, 0, 0, 0, 0, 0, 0, 0, 1]
```

Для проверки, корректно ли загрузились данные, мы можем произвольно указать номер элемента массива с цифрами и посмотреть его содержимое:

![](.\images\010_colab_interface.png)

После запуска этого кода мы увидим цифру 3.

![](.\images\011_colab_interface.png)

Далее мы производим преобразование размерности данных в обучающем наборе картинок – это необходимо для корректной работы с ними в дальнейшем.

![](.\images\012_colab_interface.webp)

Изначально на вход сети в обучающей выборке подается 60 тыс. изображений размером 28 на 28 пикселей. В тестовой выборке таких изображений 10 тыс. штук. Наша задача - привести их к одномерному массиву (вектору), размерность которого будет не 28 на 28, а 1 на 784, что мы и делаем в коде выше.

Следующий наш шаг – это так называемая нормализация данных, их "выравнивание" с целью привести их значения к диапазону от 0 до 1. Дело в том, что до нормализации изображение каждой рукописной цифры (все они представлены в градациях серого) представлено числами от 0 до 255, где 0 представляет собой чёрный цвет, а 255 — белый). Однако для эффективной работы сети нам необходимо привести их к другому диапазону, что мы и делаем, разделив каждое значение на 255.

![](.\images\013_colab_interface.webp)

Теперь давайте убедимся в том, что в массиве ответов находятся верные ответы. Для этого мы можем запустить код ниже и убедиться, что в указанном нами выше элементе массива 157 действительно хранится ответ, что это цифра 3:

![](.\images\014_colab_interface.webp)

Следующий шаг – это преобразование массива правильных ответов в формат про который мы уже упоминали выше.

![](.\images\015_colab_interface.webp)

Производит это преобразование функция `to_categorical`, которая трансформирует цифры от нуля до девяти в вектор из десяти цифр, в результате чего наш правильный ответ 3 будет теперь выводиться в ином виде:

![](.\images\016_colab_interface.webp)

Единица в четвертой позиции этого массива как раз обозначает цифру 3.



##### Создание нейронной сети

На этом сбор данных и их простая предобработка завершены. Дальше нам нужно будет создать нейронную сеть и задать её архитектуру. В нашем случае мы создадим последовательную сеть прямого распространения, пример которой мы рассматривали самым первым, когда говорили про типы архитектур.





##### Обучение нейронной сети



##### Сохранение обученной нейронной сети



##### Использование сети для распознавания рукописных цифр









### Запуск нейронной сети на компьютере - на примере распознания цветов

ВНИМАНИЕ - ДАННЫЙ БЛОК МОЖЕТ БЫТЬ НЕВЫПОЛНЕН, ТАК КАК НЕ ВСЕ КОМПЬЮТЕРЫ ПОДЕРЖИВАЮТ РАБОТУ С БИБЛИОТЕКОЙ *TENSORFLOW*.

Настроим и обучим нейросеть распознавать картинки и говорить, какой цветок мы ей показываем — розу, тюльпан или что-то другое. Мы используем цветы, потому что скачали уже готовый, собранный и размеченный набор фотографий, на котором нейросеть может научиться. 

> Если вы хотите, чтобы она научилась распознавать на фото вас или ваших друзей, нужно будет собрать другой датасет и переобучить нейросеть.

Понадобится *Python* версии *3.8* и выше, обязательно под архитектуру *x64*. Если взять *32*-разрядную версию, то нужная в проекте библиотека *Tensorflow*  работать не будет. Мы используем версию [*3.9.7*](https://www.python.org/downloads/release/python-397/). Инструкция по [установке Python](https://thecode.media/py-install/). 

Все команды, которые есть в проекте, мы будем запускать в командной строке. Чтобы не было ошибок, лучше всего запустить её от имени администратора (в *Windows*) или с правами суперпользователя root (в *Mac OS* и *Linux*).

Весь код проекта можно посмотреть [тут](https://github.com/mlnchkdv/mlnchkdv.github.io/tree/main/dl2022.1/4_running/flower_classifier).



#### Создаём виртуальное окружение

Чтобы не раскидывать файлы, скрипты и картинки по всему компьютеру, создадим в питоне виртуальное окружение — специальный проект, который хранит все данные внутри своей папки. Он не мешает остальным проектам и не влияет на работу других программ, а также позволяет разворачивать проект на любом другом компьютере, где есть *Python*. Подробнее про *Virtual Environments* встроенный в *Puthon* и запуск файла [requirements.txt](./flower_classifier/requirements.txt) смотри в [инструкции](https://python.ivan-shamaev.ru/python-virtual-env-packages-virtualenv-venv-requirements-txt/).

Чтобы создать виртуальное окружение, в терминале перейдите в папку проекта и запустите команду:

```bash
python -m venv venv
```

В результате, в папке проекта будет создана папка **venv** с содержимым:

![](.\images\python_venv_env.jpg)

Далее необходимо активировать виртуальную среду, введя команду:

```bash
.\venv\Scripts\Activate.ps1
```

Префикс вашего рабочего каталога изменится на venv. Теперь пока ваша виртуальная среда активирована, **pip будет устанавливать пакеты в эту конкретную среду**, и вы сможете импортировать и использовать пакеты в своем приложении Python.

Теперь можно устанавливать пакеты в нашу виртуальную среду. Вы можете устанавливать каждый пакет по отдельности, вводя команду:

```bash
pip install pandas
```

Так вы получите последнюю версию пакеты, но можно указывать конкретную версию пакета, чтобы не столкнуться с несовместимостью некоторых новых функций:

```bash
pip install pandas==0.25.0
```

Для удобства, можно заранее вынести весь список необходимых библиотек в отдельный файл [requirements.txt](./flower_classifier/requirements.txt) и установить пакеты сразу все из этого списка, сохраним данный файл в корне проекта и запустим:

```bash
pip install -r requirements.txt
```

Последняя операция может занять некоторое время. После чего у вас в виртуальном окружении будут установлены все необходимые пакеты для дальнейшей работы.

![](.\images\consoleVSC.png)

> `tensorflow` - 280 МБ, `pandas` - 10 МБ, `numpy` - 14 МБ и небольшие зависимые библиотеки будут загружены и установлены автоматически. 



#### Установка *Tensorflow* 

На случай проблем с автоматической установкой *Tensorflow*, рассмотрим этап отдельной установки. Для установки пишем команду:

```bash
pip install tensorflow
```

Если на вашем компьютере установлен GPU и вы хотите задействовать его, то необходимо отменить установку пакета `tensorflow` и установить вместо него пакет `tensorflow-gpu`:

```bash
pip uninstall tensorflow
pip install tensorflow-gpu
```

Также может потребоваться установить совместимую библиотеку GPU.

Чтобы убедиться, что библиотека установилась правильно и работает штатно, проверим её простым тестом. Пишем команду:

```
python
```

Начало командной строки поменялось на `>>>` — это значит, что питон готов к приёму команд. Пишем по очереди:

```python
hello = tf.constant('Hello, TensorFlow')
sess = tf.compat.v1.Session()
print(sess.run(hello))
```

Если в консоли распечаталось 'Hello, TensorFlow', это значит, что всё работает правильно.



#### Устанавка классификатора

Задача классификатора — научить нейросеть понимать, чем одни цветы отличаются от других. Если бы мы вместо цветов использовали фото зданий, нейронка бы научилась отличать барокко от роккоко и неоклассицизма.

У *Tensorflow* есть уже предобученный классификатор и готовые учебные проекты показывающие разные возможности библиотеки. Воспользуемся одним из таких проектов.

1. [Качаем архив с классификатором](https://github.com/googlecodelabs/tensorflow-for-poets-2/archive/refs/heads/master.zip)(28 МБ).
2. Распаковываем архив.

![](.\images\image6-1-1920x454.png)

3. Копируем содержимое архива в папку вашего проекта.



#### Загрузка фотографий для обучения

Скачиваем уже собранный [датасет с цветами](https://drive.google.com/file/d/1_RO4G5D6luaBGvWeQdStPeK426cMrNZk/view?usp=sharing)(218 МБ), распаковываем его и копируем в папку вашего проекта.



#### Адаптация скриптов под актуальную версию *Tensorflow*

На текущий момент актуальная версия *tensorflow* — 2.8. Но скрипты и алгоритмы, которые мы используем, были написаны под старую версию, поэтому необходимо их адаптировать под новую версию.

1. Переходим в каталог вашего проекта в папку `/scripts` и находим файл `retrain.py`.

2. Открываем его в любом редакторе кода.

3. Нажимаем `Ctrl + H` или `Command + H` — включится режим поиска и автозамены текста.

4. Первая строка (что заменить) → пишем `tf. `(с точкой).

5. Вторая строка (на что заменить) → пишем `tf.compat.v1.` (тоже с точкой в конце).

6. Нажимаем `Replace All` (Заменить всё).

7. То же самое делаем в файле `label-image.py`.

8. В том же файле `label-image.py` добавляем после строки 25 «`import tensorflow as tf`» такую строку:

   ```python
   tf.compat.v1.disable_eager_execution ()
   ```

Благодаря действиям выше мы сможем запустить написанный под старую версию скрипт работать с новой версией.

![](.\images\retrain.png)



#### Обучение нейронной сети

1. В командной строке командой `cd` переходим в папку вашего проекта.

2. Запускаем команду:

   ```bash
   python scripts/retrain.py --output_graph=tf_files/retrained_graph.pb --output_labels=tf_files/retrained_labels.txt --image_dir=flower_photos
   ```


Пошёл процесс обучения. В нём 4000 этапов, по времени занимает примерно 20 минут. За это время нейросеть обработает около 250 фото (это очень мало для нейросети) и научится отличать розу от ландышей:

![](.\images\image10-1920x771.png)



#### Запуск нейронной сети

Чтобы проверить работу нашей нейросети, скачиваем [любой файл с розой](https://i.pinimg.com/originals/b9/15/f0/b915f0e7361a1d1bb618c422a09f8451.jpg) из интернета, кладём его в папку проекта и пишем такую команду:

```bash
python scripts/label_image.py --image image.jpg
```

Нейросеть думает, а потом выдаёт ответ в виде процентов. В нашем случае она на 98% уверена, что это роза:

![](.\images\image5-1-1920x922.png)

А вот как нейросеть реагирует [на фото Цукерберга](https://www.kino-teatr.ru/news/9883/97057.jpg):

![](.\images\image1-2-1920x395.png)

50% — что на фото тюльпан, и на 18% — что это одуванчик. А всё потому, что она умеет различать только 5 видов цветов, а не лица.











### Выводы



### Тест





---

### Источники





### Дополнительные материалы